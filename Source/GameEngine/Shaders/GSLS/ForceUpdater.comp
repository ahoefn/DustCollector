#version 450 core

layout(local_size_x=64, local_size_y=1, local_size_z=1) in;
layout(std430,binding=0)  buffer positionsBuffer
{
    float pos[];
} positions;

layout(std430,binding=1)  buffer forcesBufferFuture 
{
    float F[];
} forcesFuture;

// Uniforms:
uniform int offSetX;
uniform int particleCount;

uint GetForceIndex(uint column, uint row,uint dir);

void main()
{    
    uint id = uint(64*dot(gl_WorkGroupID, vec3(1,1,1))) + gl_LocalInvocationID.x + 64 * offSetX;
    if (!(id < particleCount-1)) {return;}

    // Must convert id to 2x2 matrix index using some index magic: 
    uint idRow = uint((sqrt(1 + 8 * id) - 1) / 2) + 1;
    uint idColumn = id - idRow * (idRow - 1) / 2;

    // Get position vectors for input and output particles 
    uint indexRow = 3 * idRow;
    uint indexColumn = 3 * idColumn;
    vec3 posRow = vec3(positions.pos[indexRow], positions.pos[indexRow + 1], positions.pos[indexRow + 2]);
    vec3 posColumn = vec3(positions.pos[indexColumn], positions.pos[indexColumn + 1], positions.pos[indexColumn + 2]);

    // Calculate force based on distance between particles.
    vec3 pos_dif = posColumn - posRow;
    float difDot = dot(pos_dif, pos_dif);
    vec3 forceVec = -pos_dif  /(difDot * sqrt(difDot));

    // Write to forcebuffer.
    forcesFuture.F[GetForceIndex(idRow-1,idColumn,0)] = forceVec.x;
    forcesFuture.F[GetForceIndex(idRow-1,idColumn,1)] = forceVec.y;
    forcesFuture.F[GetForceIndex(idRow-1,idColumn,2)] = forceVec.z;
 
    // As the force matrix is antisymmetric, we can also write to the other particle:
    forcesFuture.F[GetForceIndex(idColumn,idRow,0)] = -forceVec.x;
    forcesFuture.F[GetForceIndex(idColumn,idRow,1)] = -forceVec.y;
    forcesFuture.F[GetForceIndex(idColumn,idRow,2)] = -forceVec.z;
} 


uint GetForceIndex(uint idRow, uint idColumn, uint dir)
{
    uint rowStart = 3 * (particleCount - 1) * idColumn;
    uint rowIndex = (particleCount - 1) * dir + idRow;
    return rowStart + rowIndex;
}