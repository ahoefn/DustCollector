#version 450 core

layout(local_size_x=64, local_size_y=1, local_size_z=1) in;
layout(std430,binding=0)  buffer positionsBuffer
{
    float pos[];
} positions;

layout(std430,binding=1)  buffer forcesBufferFuture 
{
    float F[];
} forcesFuture;

// Uniforms:
uniform int offSetX;
uniform int particleCount;

void main()
{    
    uint id = uint(64*dot(gl_WorkGroupID, vec3(1,1,1))) + gl_LocalInvocationID.x + 64 * offSetX;

    // Must convert id to 2x2 matrix index using some index magic: 
    uint id_in = uint((sqrt(1 + 8 * id) - 1) / 2);
    uint id_out = (id - id_in * (id_in + 1) / 2);
    uint index_in = 3 * (id_in + 1);
    uint index_out = 3 * id_out;

    // Get position vectors for input and output particles 
    vec3 pos_in = vec3(positions.pos[index_in], positions.pos[index_in + 1], positions.pos[index_in + 2]);
    vec3 pos_out = vec3(positions.pos[index_out], positions.pos[index_out + 1], positions.pos[index_out + 2]);

    // Calculate force based on distance between particles.
    vec3 pos_dif = pos_out - pos_in;
    float difDot = dot(pos_dif, pos_dif);
    vec3 forceVec = 1  /(difDot * sqrt(difDot)) * pos_dif;

    // Write to forcebuffer.
    forcesFuture.F[index_out +  particleCount * index_in] = forceVec.x;
    forcesFuture.F[index_out +  particleCount * index_in + 1] = forceVec.y;
    forcesFuture.F[index_out +  particleCount * index_in + 2] = forceVec.z;
 
    // As the force matrix is antisymmetric, we can also write to the other particle:
    forcesFuture.F[index_in +  particleCount * index_out] = -forceVec.x;
    forcesFuture.F[index_in +  particleCount * index_out + 1] = -forceVec.y;
    forcesFuture.F[index_in +  particleCount * index_out + 2] = -forceVec.z;
    forcesFuture.F[index_in] = index_in;
    forces.Future.F[]
}